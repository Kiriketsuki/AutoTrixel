<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AutoTrixel</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #252525;
            --text-color: #e0e0e0;
            --accent: #00d2ff;
            --accent-hover: #33dfff;
            --border: #333;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* Helps prevent default touch actions globally */
        }

        /* --- Sidebar --- */
        #sidebar {
            width: 320px;
            min-width: 320px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 20;
            overflow-y: auto;
            transition: margin-left 0.3s ease-in-out;
            touch-action: pan-y; /* Allow vertical scrolling in sidebar */
        }

        /* Collapsed State */
        body.sidebar-closed #sidebar {
            margin-left: -321px; /* Hide completely */
        }

        /* Sidebar Toggle Button */
        #sidebarToggle {
            position: fixed;
            top: 10px;
            left: 330px; /* Position next to open sidebar */
            z-index: 30;
            background: var(--panel-bg);
            border: 1px solid var(--border);
            color: var(--accent);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            transition: left 0.3s ease-in-out, transform 0.2s;
        }

        #sidebarToggle:hover {
            transform: scale(1.1);
        }

        body.sidebar-closed #sidebarToggle {
            left: 10px; /* Move to edge when closed */
        }

        h1 {
            font-size: 1.4rem;
            margin: 0;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 0.8rem;
            color: #888;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Tools */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .tool-btn {
            background: #333;
            border: 1px solid #444;
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .tool-btn:hover {
            background: #444;
        }

        .tool-btn.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            font-weight: bold;
        }
        
        .undo-btn {
            background: #444;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.85rem;
        }
        .undo-btn:active { background: #333; }
        .undo-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Tutorial Box */
        .tutorial-box {
            background: rgba(0,0,0,0.2);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.75rem;
            color: #ccc;
        }
        .tutorial-box h3 {
            margin: 0 0 5px 0;
            color: var(--accent);
            font-size: 0.85rem;
        }
        .key-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }
        .key-row:last-child { border: none; margin: 0; }
        .kbd {
            background: #222;
            padding: 1px 4px;
            border-radius: 3px;
            font-family: monospace;
            border: 1px solid #555;
            color: #fff;
        }

        /* Color Section */
        .color-section {
            border-top: 1px solid #333;
            padding-top: 15px;
        }

        .color-preview-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #colorPreviewBox {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #555;
            background-color: #00d2ff;
        }
        
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .slider-label {
            font-size: 0.75rem;
            color: #aaa;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 5px;
        }

        .swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s;
        }

        .swatch:hover {
            transform: scale(1.1);
            z-index: 2;
        }

        .swatch.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--accent);
        }

        /* Inputs */
        .input-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
            height: 4px;
        }

        input[type="number"] {
            width: 60px;
            background: #111;
            border: 1px solid #444;
            color: var(--accent);
            padding: 4px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.9rem;
            text-align: right;
        }
        input[type="number"]:focus { outline: none; border-color: var(--accent); }

        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            background: none;
            cursor: pointer;
        }

        .value-display { font-size: 0.8rem; color: var(--accent); }

        button.action-btn {
            background: #333;
            color: white;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
            margin-top: 5px;
        }

        button.action-btn:hover { background: #444; border-color: #666; }

        button.primary { background: var(--accent); color: #000; border: none; }
        button.primary:hover { background: var(--accent-hover); }
        
        .btn-group { display: flex; gap: 8px; }

        /* Canvas Area */
        #workspace {
            flex: 1;
            position: relative;
            background-color: #121212;
            /* Checkered transparency pattern */
            background-image: 
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #1a1a1a 75%), 
                linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
            touch-action: none; /* Prevent scroll on workspace */
        }

        #canvas-stack {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            line-height: 0;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        #artLayer { z-index: 1; }
        #cursorLayer {
            position: absolute;
            top: 0; left: 0;
            z-index: 2;
            pointer-events: auto; 
            cursor: none; 
        }
        
        #toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent);
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
            pointer-events: none;
            z-index: 100;
        }
        
        #toast.show { opacity: 1; transform: translateY(0); }

    </style>
</head>
<body>

    <!-- Sidebar Toggle -->
    <button id="sidebarToggle" onclick="document.body.classList.toggle('sidebar-closed')" title="Toggle Sidebar">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
    </button>

    <div id="sidebar">
        <h1>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 21h22L12 2zm0 3.516L19.297 19H4.703L12 5.516z"/></svg>
            AutoTrixel
        </h1>
        
        <!-- Tutorial Box -->
        <div class="tutorial-box">
            <h3>Shortcuts</h3>
            <div class="key-row"><span>Undo</span> <span class="kbd">Ctrl + Z</span></div>
            <div class="key-row"><span>Zoom In/Out</span> <span class="kbd">Ctrl + [ / ]</span></div>
            <div class="key-row"><span>Brush Size</span> <span class="kbd">Ctrl + - / +</span></div>
            <div class="key-row"><span>Scroll/Zoom</span> <span class="kbd">Ctrl + Wheel</span></div>
        </div>

        <div class="control-group">
            <label>Tools</label>
            <div class="tools-grid">
                <button class="tool-btn active" id="tool-pencil" onclick="window.setTool('pencil')">‚úèÔ∏è Draw</button>
                <button class="tool-btn" id="tool-bucket" onclick="window.setTool('bucket')">ü™£ Fill</button>
                <button class="tool-btn" id="tool-eraser" onclick="window.setTool('eraser')">üßπ Erase</button>
                <button class="tool-btn" id="tool-picker" onclick="window.setTool('picker')">üß™ Pick</button>
            </div>
            <button class="undo-btn" id="btnUndo" onclick="window.undoAction()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/></svg>
                Undo (Ctrl+Z)
            </button>
        </div>
        
        <div class="control-group">
            <label>Brush Size <span id="brushVal" class="value-display">1</span></label>
            <input type="range" id="brushInput" min="1" max="5" value="1">
        </div>

        <!-- OKLCH Color Editor -->
        <div class="control-group color-section">
            <label>Color Editor (OKLCH)</label>
            <div class="color-preview-row">
                <div id="colorPreviewBox"></div>
                <div style="flex:1; font-family: monospace; font-size: 0.8rem; color: #888;" id="colorCodeDisplay">#00d2ff</div>
            </div>

            <div class="slider-row">
                <span class="slider-label">Lightness (L)</span>
                <input type="range" id="lInput" min="0" max="100" value="60">
            </div>
            <div class="slider-row">
                <span class="slider-label">Chroma (C)</span>
                <input type="range" id="cInput" min="0" max="0.37" step="0.01" value="0.15">
            </div>
            <div class="slider-row">
                <span class="slider-label">Hue (H)</span>
                <input type="range" id="hInput" min="0" max="360" value="200">
            </div>

            <label style="margin-top: 10px;">Quick Palette</label>
            <div class="palette" id="palette">
                <!-- Generated by JS -->
            </div>
        </div>

        <div class="control-group">
            <label>Triangle Scale (px)</label>
            <div class="input-row">
                <input type="range" id="scaleSlider" min="5" max="200" value="25">
                <input type="number" id="scaleNumber" min="5" max="200" value="25">
            </div>
        </div>

        <div class="control-group">
            <label>Grid Width</label>
            <div class="input-row">
                <input type="range" id="widthSlider" min="5" max="500" value="40">
                <input type="number" id="widthNumber" min="5" max="500" value="40">
            </div>
        </div>

        <div class="control-group">
            <label>Grid Height</label>
            <div class="input-row">
                <input type="range" id="heightSlider" min="5" max="500" value="30">
                <input type="number" id="heightNumber" min="5" max="500" value="30">
            </div>
        </div>

        <div class="control-group">
            <label>Grid Settings</label>
            <div style="display: flex; gap: 10px; align-items: center; justify-content: space-between;">
                <span style="font-size: 0.85rem">Show Grid</span>
                <input type="checkbox" id="gridToggle" checked>
            </div>
             <div style="display: flex; gap: 10px; align-items: center; justify-content: space-between; margin-top: 5px;">
                <span style="font-size: 0.85rem">Grid Color</span>
                <input type="color" id="gridColorPicker" value="#222222" style="width: 40px; height: 25px;">
            </div>
        </div>
        
        <div class="control-group">
            <label style="color: var(--accent);">
                Include Grid in Export
                <input type="checkbox" id="exportGridToggle">
            </label>
        </div>

        <div style="margin-top: auto;">
            <button class="action-btn" style="width: 100%" onclick="window.resetCanvas()">Clear Canvas</button>
            <div class="btn-group">
                <button class="action-btn primary" style="flex:1" onclick="window.exportImage()">PNG</button>
                <button class="action-btn primary" style="flex:1" onclick="window.exportSVG()">SVG</button>
            </div>
        </div>
    </div>

    <div id="workspace">
        <div id="canvas-stack">
            <canvas id="cursorLayer"></canvas>
            <canvas id="artLayer"></canvas>
        </div>
    </div>
    
    <div id="toast">Image Saved!</div>

    <script>
        (function() {
            // Layer References
            const artCanvas = document.getElementById('artLayer');
            const artCtx = artCanvas.getContext('2d', { alpha: true });
            const cursorCanvas = document.getElementById('cursorLayer');
            const cursorCtx = cursorCanvas.getContext('2d');
            const canvasStack = document.getElementById('canvas-stack');
            const toast = document.getElementById('toast');
            
            // Configuration
            let config = {
                triSide: 25,
                widthTriangles: 40,
                heightTriangles: 30,
                bgColor: 'transparent',
                gridColor: '#222222',
                showGrid: true,
                brushSize: 1
            };

            // State
            let gridData = {}; 
            let hoveredCells = [];
            let isDrawing = false;
            let currentTool = 'pencil';
            let storedBrushSize = 1;
            let lastMouseX = 0;
            let lastMouseY = 0;

            // Undo History
            let historyQueue = [];
            const MAX_HISTORY = 10;
            let tempSnapshot = null;

            // Color State (OKLCH)
            let colorState = { l: 0.6, c: 0.15, h: 200 };
            let currentCssColor = 'oklch(60% 0.15 200)';
            
            // Derived dimensions
            let triHeight, W_half;

            // --- Math Helpers ---
            function hexToOklchVals(hex) {
                let r = parseInt(hex.substring(1,3), 16) / 255;
                let g = parseInt(hex.substring(3,5), 16) / 255;
                let b = parseInt(hex.substring(5,7), 16) / 255;

                r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                const l = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
                const m = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
                const s = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

                const l_ = Math.cbrt(l);
                const m_ = Math.cbrt(m);
                const s_ = Math.cbrt(s);

                const L = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
                const a = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
                const b_ = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

                const C = Math.sqrt(a * a + b_ * b_);
                let H = Math.atan2(b_, a) * 180 / Math.PI;
                if (H < 0) H += 360;

                return { l: L, c: C, h: H };
            }

            function syncColorFromHex(hex) {
                const vals = hexToOklchVals(hex);
                colorState.l = vals.l;
                colorState.c = vals.c;
                colorState.h = vals.h;
                updateColorUI(hex);
            }

            function updateColorFromSliders() {
                const L = parseFloat(document.getElementById('lInput').value) / 100;
                const C = parseFloat(document.getElementById('cInput').value);
                const H = parseFloat(document.getElementById('hInput').value);

                colorState = { l: L, c: C, h: H };
                const cssStr = `oklch(${Math.round(L*100)}% ${C} ${Math.round(H)})`;
                updateColorUI(cssStr);
            }

            function updateColorUI(cssString) {
                currentCssColor = cssString;
                document.getElementById('colorPreviewBox').style.backgroundColor = cssString;
                document.getElementById('lInput').value = Math.round(colorState.l * 100);
                document.getElementById('cInput').value = colorState.c;
                document.getElementById('hInput').value = Math.round(colorState.h);
                
                if(cssString.startsWith('#')) {
                     document.getElementById('colorCodeDisplay').innerText = cssString;
                } else {
                     document.getElementById('colorCodeDisplay').innerText = 
                        `L:${Math.round(colorState.l*100)} C:${colorState.c.toFixed(2)} H:${Math.round(colorState.h)}`;
                }
                
                if(currentTool === 'eraser' || currentTool === 'picker') {
                    window.setTool('pencil');
                }
            }

            // --- Undo ---
            function saveStateForUndo() {
                return JSON.stringify(gridData);
            }

            function pushToHistory(snapshot) {
                historyQueue.push(snapshot);
                if (historyQueue.length > MAX_HISTORY) {
                    historyQueue.shift();
                }
                updateUndoButton();
            }

            window.undoAction = function() {
                if (historyQueue.length === 0) {
                    showToast("Nothing to Undo");
                    return;
                }
                const previousState = historyQueue.pop();
                gridData = JSON.parse(previousState);
                fullRedraw();
                updateUndoButton();
                showToast("Undo");
            }

            function updateUndoButton() {
                const btn = document.getElementById('btnUndo');
                btn.disabled = historyQueue.length === 0;
                btn.style.opacity = historyQueue.length === 0 ? '0.5' : '1';
            }

            // --- Init ---
            function init() {
                updateDimensions();
                setupPalette();
                setupEvents();
                fullRedraw();
                updateColorFromSliders(); 
                updateUndoButton();
            }

            function updateDimensions() {
                triHeight = config.triSide * Math.sqrt(3) / 2;
                W_half = config.triSide / 2;
                
                const w = Math.ceil(config.widthTriangles * W_half + W_half);
                const h = Math.ceil(config.heightTriangles * triHeight);
                
                artCanvas.width = w;
                artCanvas.height = h;
                cursorCanvas.width = w;
                cursorCanvas.height = h;
                
                canvasStack.style.width = w + "px";
                canvasStack.style.height = h + "px";
                
                fullRedraw();
            }

            // --- Grid Logic ---
            function pixelToGrid(x, y) {
                const row = Math.floor(y / triHeight);
                const colApprox = Math.floor(x / W_half);
                const localX = (x % W_half) / W_half;
                const localY = (y % triHeight) / triHeight;
                let finalCol = -1;
                const parity = (colApprox + row) % 2;
                
                if (parity === 0) {
                    const isEvenRow = (row % 2 === 0);
                    if (isEvenRow) {
                        if (colApprox % 2 === 0) {
                            if (localX + localY >= 1) finalCol = colApprox;
                            else finalCol = colApprox - 1;
                        } else {
                            if (localY >= localX) finalCol = colApprox - 1;
                            else finalCol = colApprox;
                        }
                    } else {
                        if (colApprox % 2 === 0) {
                            if (localX >= localY) finalCol = colApprox;
                            else finalCol = colApprox - 1;
                        } else {
                            if (localX + localY <= 1) finalCol = colApprox - 1;
                            else finalCol = colApprox;
                        }
                    }
                }
                
                if (row < 0 || row >= config.heightTriangles) return null;
                if (finalCol < 0 || finalCol >= config.widthTriangles) return null;

                return { r: row, c: finalCol };
            }

            function getTriangleCluster(r, c, size) {
                if (size <= 1) return [{r, c}];
                const coords = [];
                const isUp = (r % 2 === Math.abs(c) % 2);
                for (let i = 0; i < size; i++) {
                    const currentRow = isUp ? r + i : r - i;
                    const startCol = c - i;
                    const endCol = c + i;
                    for (let col = startCol; col <= endCol; col++) {
                        if (currentRow >= 0 && currentRow < config.heightTriangles &&
                            col >= 0 && col < config.widthTriangles) {
                            coords.push({r: currentRow, c: col});
                        }
                    }
                }
                return coords;
            }

            function getTrianglePath(r, c) {
                const path = new Path2D();
                const xBase = c * W_half;
                const yBase = r * triHeight;
                const isUp = (r % 2 === Math.abs(c) % 2);
                
                if (isUp) {
                    path.moveTo(xBase, yBase + triHeight);
                    path.lineTo(xBase + 2 * W_half, yBase + triHeight);
                    path.lineTo(xBase + W_half, yBase);
                    path.closePath();
                } else {
                    path.moveTo(xBase, yBase);
                    path.lineTo(xBase + 2 * W_half, yBase);
                    path.lineTo(xBase + W_half, yBase + triHeight);
                    path.closePath();
                }
                return path;
            }

            // --- Rendering ---
            function fullRedraw() {
                artCtx.clearRect(0, 0, artCanvas.width, artCanvas.height);
                
                if (config.bgColor !== 'transparent') {
                    artCtx.fillStyle = config.bgColor;
                    artCtx.fillRect(0, 0, artCanvas.width, artCanvas.height);
                }

                const keys = Object.keys(gridData);
                keys.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    const color = gridData[key];
                    const path = getTrianglePath(r, c);
                    artCtx.fillStyle = color;
                    artCtx.fill(path);
                    artCtx.strokeStyle = color;
                    artCtx.lineWidth = 0.5;
                    artCtx.stroke(path);
                });

                if (config.showGrid) {
                    drawGridLines(artCtx);
                }
            }

            function drawCursor() {
                cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
                if (hoveredCells.length === 0) return;

                cursorCtx.lineWidth = 2;
                cursorCtx.lineCap = 'round';
                cursorCtx.lineJoin = 'round';
                
                if (currentTool === 'eraser') cursorCtx.strokeStyle = '#ff4444';
                else if (currentTool === 'picker') cursorCtx.strokeStyle = '#ffff00';
                else if (currentTool === 'bucket') cursorCtx.strokeStyle = '#00ff00';
                else cursorCtx.strokeStyle = '#ffffff';
                
                cursorCtx.shadowColor = 'rgba(0,0,0,0.8)';
                cursorCtx.shadowBlur = 4;

                hoveredCells.forEach(cell => {
                    const path = getTrianglePath(cell.r, cell.c);
                    cursorCtx.stroke(path);
                });
                
                cursorCtx.shadowColor = 'transparent';
                cursorCtx.shadowBlur = 0;
            }

            function drawGridLines(ctx) {
                if (config.widthTriangles * config.heightTriangles > 400000) return; 
                
                ctx.strokeStyle = config.gridColor;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                
                for (let r = 0; r <= config.heightTriangles; r++) {
                    ctx.moveTo(0, r * triHeight);
                    ctx.lineTo(artCanvas.width, r * triHeight);
                }
                
                for (let r = 0; r < config.heightTriangles; r++) {
                    for (let c = 0; c < config.widthTriangles; c++) {
                        const xBase = c * W_half;
                        const yBase = r * triHeight;
                        const isUp = (r % 2 === Math.abs(c) % 2);
                        if (isUp) {
                            ctx.moveTo(xBase, yBase + triHeight);
                            ctx.lineTo(xBase + W_half, yBase);
                            ctx.lineTo(xBase + 2 * W_half, yBase + triHeight);
                        } else {
                            ctx.moveTo(xBase, yBase);
                            ctx.lineTo(xBase + W_half, yBase + triHeight);
                            ctx.lineTo(xBase + 2 * W_half, yBase);
                        }
                    }
                }
                ctx.stroke();
            }

            // --- Interaction & Interpolation ---
            
            function batchPaintCells(cells) {
                let didChange = false;
                cells.forEach(cell => {
                    const key = `${cell.r},${cell.c}`;
                    if (currentTool === 'pencil') {
                        if (gridData[key] !== currentCssColor) {
                            gridData[key] = currentCssColor;
                            didChange = true;
                        }
                    } else if (currentTool === 'eraser') {
                        if (gridData[key]) {
                            delete gridData[key];
                            didChange = true;
                        }
                    }
                });
                return didChange;
            }

            function interpolateStroke(x0, y0, x1, y1) {
                const dx = x1 - x0;
                const dy = y1 - y0;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const stepSize = Math.max(1, config.triSide / 3);
                const steps = Math.ceil(dist / stepSize);
                
                let uniqueCells = [];
                let seenKeys = new Set();
                
                for (let i = 0; i <= steps; i++) {
                    const t = steps === 0 ? 0 : i / steps;
                    const x = x0 + dx * t;
                    const y = y0 + dy * t;
                    
                    const centerCell = pixelToGrid(x, y);
                    if (centerCell) {
                        const useSize = (currentTool === 'picker' || currentTool === 'bucket') ? 1 : config.brushSize;
                        const cluster = getTriangleCluster(centerCell.r, centerCell.c, useSize);
                        
                        cluster.forEach(c => {
                            const k = `${c.r},${c.c}`;
                            if (!seenKeys.has(k)) {
                                seenKeys.add(k);
                                uniqueCells.push(c);
                            }
                        });
                    }
                }
                return uniqueCells;
            }

            function handleSingleClick() {
                if (hoveredCells.length === 0) return false;
                
                let didChange = false;

                if (currentTool === 'bucket') {
                    const cell = hoveredCells[0];
                    didChange = fillBucket(cell.r, cell.c, currentCssColor);
                } 
                else if (currentTool === 'picker') {
                    const cell = hoveredCells[0];
                    const key = `${cell.r},${cell.c}`;
                    const color = gridData[key];
                    if (color) {
                        if(color.startsWith('#')) {
                            syncColorFromHex(color);
                        } else if (color.startsWith('oklch')) {
                            const matches = color.match(/oklch\(([\d\.]+)%\s+([\d\.]+)\s+([\d\.]+)\)/);
                            if(matches) {
                                colorState.l = parseFloat(matches[1])/100;
                                colorState.c = parseFloat(matches[2]);
                                colorState.h = parseFloat(matches[3]);
                                updateColorUI(color);
                            }
                        }
                        showToast("Color Picked");
                    }
                }
                else {
                    didChange = batchPaintCells(hoveredCells);
                }
                
                if (didChange) {
                    fullRedraw();
                }
                return didChange;
            }

            function fillBucket(startR, startC, fillCol) {
                const startKey = `${startR},${startC}`;
                const targetColor = gridData[startKey];
                
                if (targetColor === fillCol) return false;
                
                const queue = [{r: startR, c: startC}];
                const visited = new Set();
                let count = 0;
                let changed = false;
                
                while(queue.length > 0) {
                    count++;
                    if(count > 500000) break;

                    const {r, c} = queue.shift();
                    const key = `${r},${c}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (gridData[key] !== targetColor) continue;
                    
                    gridData[key] = fillCol;
                    changed = true;
                    
                    const isUp = (r % 2 === Math.abs(c) % 2);
                    addNeighbor(r, c - 1, queue);
                    addNeighbor(r, c + 1, queue);
                    if (isUp) {
                        addNeighbor(r + 1, c, queue); 
                    } else {
                        addNeighbor(r - 1, c, queue);
                    }
                }
                return changed;
            }
            
            function addNeighbor(r, c, queue) {
                if (r >= 0 && r < config.heightTriangles && c >= 0 && c < config.widthTriangles) {
                    queue.push({r, c});
                }
            }

            // --- Events ---
            function updateBrushSize(change) {
                let newSize = (currentTool === 'picker' || currentTool === 'bucket') ? storedBrushSize : config.brushSize;
                newSize += change;
                if (newSize < 1) newSize = 1;
                if (newSize > 5) newSize = 5;
                
                if (newSize !== config.brushSize) {
                    if (currentTool === 'picker' || currentTool === 'bucket') {
                        storedBrushSize = newSize;
                        showToast(`Saved Brush Size: ${newSize}`);
                    } else {
                        config.brushSize = newSize;
                        storedBrushSize = newSize;
                        document.getElementById('brushInput').value = newSize;
                        document.getElementById('brushVal').innerText = newSize;
                        drawCursor();
                        showToast(`Brush Size: ${newSize}`);
                    }
                }
            }
            
            function zoom(change) {
                let newSize = config.triSide + change;
                if (newSize < 5) newSize = 5;
                if (newSize > 200) newSize = 200; 
                
                if(newSize !== config.triSide) {
                    config.triSide = newSize;
                    document.getElementById('scaleSlider').value = newSize;
                    document.getElementById('scaleNumber').value = newSize;
                    updateDimensions();
                    showToast(`Zoom: ${newSize}px`);
                }
            }
            
            function showToast(msg) {
                toast.innerText = msg;
                toast.classList.add('show');
                if (window.toastTimeout) clearTimeout(window.toastTimeout);
                window.toastTimeout = setTimeout(() => toast.classList.remove('show'), 1500);
            }

            function setupEvents() {
                // Mouse Events
                cursorCanvas.addEventListener('mousedown', e => {
                    const rect = cursorCanvas.getBoundingClientRect();
                    lastMouseX = e.clientX - rect.left;
                    lastMouseY = e.clientY - rect.top;
                    
                    tempSnapshot = saveStateForUndo();
                    isDrawing = true;
                    
                    handleSingleClick();
                });
                
                window.addEventListener('mouseup', () => {
                    if (isDrawing) {
                        isDrawing = false;
                        const newState = JSON.stringify(gridData);
                        if (newState !== tempSnapshot) {
                            pushToHistory(tempSnapshot);
                        }
                    }
                });
                
                cursorCanvas.addEventListener('mousemove', e => {
                    const rect = cursorCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const cell = pixelToGrid(x, y);
                    
                    if (cell) {
                        const useSize = (currentTool === 'picker' || currentTool === 'bucket') ? 1 : config.brushSize;
                        hoveredCells = getTriangleCluster(cell.r, cell.c, useSize);
                    } else {
                        hoveredCells = [];
                    }
                    drawCursor();

                    if (isDrawing) {
                        if (currentTool !== 'bucket' && currentTool !== 'picker') {
                            const cellsToPaint = interpolateStroke(lastMouseX, lastMouseY, x, y);
                            if (cellsToPaint.length > 0) {
                                const didChange = batchPaintCells(cellsToPaint);
                                if (didChange) fullRedraw();
                            }
                        }
                    }
                    
                    lastMouseX = x;
                    lastMouseY = y;
                });
                
                cursorCanvas.addEventListener('mouseleave', () => {
                    hoveredCells = [];
                    isDrawing = false;
                    drawCursor();
                });

                // Touch Events
                cursorCanvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        const rect = cursorCanvas.getBoundingClientRect();
                        lastMouseX = touch.clientX - rect.left;
                        lastMouseY = touch.clientY - rect.top;
                        
                        tempSnapshot = saveStateForUndo();
                        isDrawing = true;
                        
                        // Update hoveredCells for the tap location immediately
                        const cell = pixelToGrid(lastMouseX, lastMouseY);
                        if (cell) {
                            const useSize = (currentTool === 'picker' || currentTool === 'bucket') ? 1 : config.brushSize;
                            hoveredCells = getTriangleCluster(cell.r, cell.c, useSize);
                        } else {
                            hoveredCells = [];
                        }
                        
                        handleSingleClick();
                    }
                }, { passive: false });

                cursorCanvas.addEventListener('touchmove', e => {
                    e.preventDefault();
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        const rect = cursorCanvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        // Update hover
                        const cell = pixelToGrid(x, y);
                        if (cell) {
                            const useSize = (currentTool === 'picker' || currentTool === 'bucket') ? 1 : config.brushSize;
                            hoveredCells = getTriangleCluster(cell.r, cell.c, useSize);
                        } else {
                            hoveredCells = [];
                        }
                        // Optional: drawCursor() if you want to see it under finger, usually hidden on touch
                        
                        if (isDrawing) {
                            if (currentTool !== 'bucket' && currentTool !== 'picker') {
                                const cellsToPaint = interpolateStroke(lastMouseX, lastMouseY, x, y);
                                if (cellsToPaint.length > 0) {
                                    const didChange = batchPaintCells(cellsToPaint);
                                    if (didChange) fullRedraw();
                                }
                            }
                        }
                        lastMouseX = x;
                        lastMouseY = y;
                    }
                }, { passive: false });

                window.addEventListener('touchend', e => {
                    if (isDrawing) {
                        isDrawing = false;
                        const newState = JSON.stringify(gridData);
                        if (newState !== tempSnapshot) {
                            pushToHistory(tempSnapshot);
                        }
                    }
                });
                
                window.addEventListener('keydown', (e) => {
                    if (e.ctrlKey) {
                        if (e.key === 'z' || e.key === 'Z') {
                            e.preventDefault();
                            window.undoAction();
                        } else if (e.key === '=' || e.key === '+') {
                            e.preventDefault(); 
                            updateBrushSize(1);
                        } else if (e.key === '-') {
                            e.preventDefault(); 
                            updateBrushSize(-1);
                        } else if (e.key === '[') {
                             e.preventDefault();
                             zoom(-5);
                        } else if (e.key === ']') {
                             e.preventDefault();
                             zoom(5);
                        }
                    }
                });

                window.addEventListener('wheel', (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault(); 
                        const delta = e.deltaY < 0 ? 1 : -1;
                        updateBrushSize(delta);
                    }
                }, { passive: false });

                // Scale (Slider + Number)
                const scaleSlider = document.getElementById('scaleSlider');
                const scaleNum = document.getElementById('scaleNumber');
                
                const updateScale = (val) => {
                    config.triSide = parseInt(val);
                    scaleSlider.value = val;
                    scaleNum.value = val;
                    updateDimensions();
                };
                scaleSlider.addEventListener('input', e => updateScale(e.target.value));
                scaleNum.addEventListener('input', e => updateScale(e.target.value));

                // Brush
                document.getElementById('brushInput').addEventListener('input', (e) => {
                    const val = parseInt(e.target.value);
                    config.brushSize = val;
                    storedBrushSize = val;
                    document.getElementById('brushVal').innerText = val;
                });

                // Width (Slider + Number)
                const widthSlider = document.getElementById('widthSlider');
                const widthNum = document.getElementById('widthNumber');
                const updateWidth = (val) => {
                    config.widthTriangles = parseInt(val);
                    widthSlider.value = val;
                    widthNum.value = val;
                    updateDimensions();
                };
                widthSlider.addEventListener('input', e => updateWidth(e.target.value));
                widthNum.addEventListener('input', e => updateWidth(e.target.value));

                // Height (Slider + Number)
                const heightSlider = document.getElementById('heightSlider');
                const heightNum = document.getElementById('heightNumber');
                const updateHeight = (val) => {
                    config.heightTriangles = parseInt(val);
                    heightSlider.value = val;
                    heightNum.value = val;
                    updateDimensions();
                };
                heightSlider.addEventListener('input', e => updateHeight(e.target.value));
                heightNum.addEventListener('input', e => updateHeight(e.target.value));

                document.getElementById('gridToggle').addEventListener('change', (e) => {
                    config.showGrid = e.target.checked;
                    fullRedraw();
                });
                
                document.getElementById('gridColorPicker').addEventListener('input', (e) => {
                    config.gridColor = e.target.value;
                    fullRedraw();
                });

                document.getElementById('lInput').addEventListener('input', updateColorFromSliders);
                document.getElementById('cInput').addEventListener('input', updateColorFromSliders);
                document.getElementById('hInput').addEventListener('input', updateColorFromSliders);
            }

            function setupPalette() {
                const colors = [
                    '#ff0000', '#ff8800', '#ffee00', '#00cc00', '#0099ff',
                    '#0000ff', '#cc00ff', '#ffffff', '#888888', '#000000',
                    '#550000', '#553300', '#555500', '#003300', '#003355'
                ];
                const p = document.getElementById('palette');
                colors.forEach(c => {
                    const div = document.createElement('div');
                    div.className = 'swatch';
                    div.style.backgroundColor = c;
                    div.onclick = () => {
                        syncColorFromHex(c);
                        showToast("Palette Color Selected");
                    };
                    p.appendChild(div);
                });
            }

            window.setTool = function(tool) {
                currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`tool-${tool}`).classList.add('active');
                
                if (tool === 'picker') cursorCanvas.style.cursor = 'crosshair';
                else cursorCanvas.style.cursor = 'none';
                
                if (tool === 'pencil' || tool === 'eraser') {
                    config.brushSize = storedBrushSize;
                    document.getElementById('brushInput').value = storedBrushSize;
                    document.getElementById('brushVal').innerText = storedBrushSize;
                }
            }

            window.resetCanvas = function() {
                pushToHistory(saveStateForUndo());
                gridData = {};
                fullRedraw();
                showToast("Canvas Cleared");
            }

            window.exportImage = function() {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = artCanvas.width;
                tempCanvas.height = artCanvas.height;
                const tCtx = tempCanvas.getContext('2d');
                
                // Explicitly clear
                tCtx.clearRect(0,0, tempCanvas.width, tempCanvas.height);
                
                if (config.bgColor !== 'transparent') {
                    tCtx.fillStyle = config.bgColor;
                    tCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
                }
                
                const keys = Object.keys(gridData);
                keys.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    const color = gridData[key];
                    const path = getTrianglePath(r, c);
                    tCtx.fillStyle = color;
                    tCtx.fill(path);
                    tCtx.strokeStyle = color;
                    tCtx.lineWidth = 0.5;
                    tCtx.stroke(path);
                });
                
                // Export Grid Toggle Check
                if (document.getElementById('exportGridToggle').checked) {
                    drawGridLines(tCtx);
                }
                
                tempCanvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = 'tripixel-art.png';
                    link.href = url;
                    link.click();
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    showToast("Image Saved!");
                }, 'image/png');
            }

            window.exportSVG = function() {
                const w = artCanvas.width;
                const h = artCanvas.height;
                let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
                
                if (config.bgColor !== 'transparent') {
                    svg += `<rect width="100%" height="100%" fill="${config.bgColor}"/>`;
                }
                
                const keys = Object.keys(gridData);
                keys.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    const color = gridData[key];
                    
                    const xBase = c * W_half;
                    const yBase = r * triHeight;
                    const isUp = (r % 2 === Math.abs(c) % 2);
                    
                    let points = "";
                    if (isUp) {
                        points = `${xBase},${yBase + triHeight} ${xBase + 2 * W_half},${yBase + triHeight} ${xBase + W_half},${yBase}`;
                    } else {
                        points = `${xBase},${yBase} ${xBase + 2 * W_half},${yBase} ${xBase + W_half},${yBase + triHeight}`;
                    }
                    
                    svg += `<polygon points="${points}" fill="${color}" stroke="${color}" stroke-width="0.5"/>`;
                });
                
                // SVG Grid Logic
                if (document.getElementById('exportGridToggle').checked) {
                    // Check complexity
                    if (config.widthTriangles * config.heightTriangles <= 400000) {
                        const gridColor = config.gridColor;
                        
                        // Horizontals
                        for (let r = 0; r <= config.heightTriangles; r++) {
                            const y = r * triHeight;
                            svg += `<line x1="0" y1="${y}" x2="${w}" y2="${y}" stroke="${gridColor}" stroke-width="0.5"/>`;
                        }
                        
                        // Diagonals (iterating cells to match canvas logic)
                        for (let r = 0; r < config.heightTriangles; r++) {
                            for (let c = 0; c < config.widthTriangles; c++) {
                                const xBase = c * W_half;
                                const yBase = r * triHeight;
                                const isUp = (r % 2 === Math.abs(c) % 2);
                                
                                let p = "";
                                if (isUp) {
                                    p = `${xBase},${yBase + triHeight} ${xBase + W_half},${yBase} ${xBase + 2 * W_half},${yBase + triHeight}`;
                                } else {
                                    p = `${xBase},${yBase} ${xBase + W_half},${yBase + triHeight} ${xBase + 2 * W_half},${yBase}`;
                                }
                                svg += `<polyline points="${p}" fill="none" stroke="${gridColor}" stroke-width="0.5"/>`;
                            }
                        }
                    }
                }
                
                svg += `</svg>`;
                
                const blob = new Blob([svg], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = 'tripixel-art.svg';
                link.href = url;
                link.click();
                setTimeout(() => URL.revokeObjectURL(url), 100);
                showToast("SVG Saved!");
            }

            init();
        })();
    </script>
</body>
</html>